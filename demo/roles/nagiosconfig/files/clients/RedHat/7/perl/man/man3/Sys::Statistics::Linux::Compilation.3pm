.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Sys::Statistics::Linux::Compilation 3"
.TH Sys::Statistics::Linux::Compilation 3 "2016-02-09" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Sys::Statistics::Linux::Compilation \- Statistics compilation.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Sys::Statistics::Linux;
\&
\&    my $lxs  = Sys::Statistics::Linux\->new( loadavg => 1 );
\&    my $stat = $lxs\->get;
\&
\&    foreach my $key ($stat\->loadavg) {
\&        print $key, " ", $stat\->loadavg($key), "\en";
\&    }
\&
\&    # or
\&
\&    use Sys::Statistics::Linux::LoadAVG;
\&    use Sys::Statistics::Linux::Compilation;
\&
\&    my $lxs  = Sys::Statistics::Linux::LoadAVG\->new();
\&    my $load = $lxs\->get;
\&    my $stat = Sys::Statistics::Linux::Compilation\->new({ loadavg => $load });
\&
\&    foreach my $key ($stat\->loadavg) {
\&        print $key, " ", $stat\->loadavg($key), "\en";
\&    }
\&
\&    # or
\&
\&    foreach my $key ($stat\->loadavg) {
\&        print $key, " ", $stat\->loadavg\->{$key}, "\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides different methods to access and filter the statistics compilation.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fInew()\fP"
.IX Subsection "new()"
Create a new \f(CW\*(C`Sys::Statistics::Linux::Compilation\*(C'\fR object. This creator is only useful if you
don't call \f(CW\*(C`get()\*(C'\fR of \f(CW\*(C`Sys::Statistics::Linux\*(C'\fR. You can create a new object with:
.PP
.Vb 3
\&    my $lxs  = Sys::Statistics::Linux::LoadAVG\->new();
\&    my $load = $lxs\->get;
\&    my $stat = Sys::Statistics::Linux::Compilation\->new({ loadavg => $load });
.Ve
.SS "Statistic methods"
.IX Subsection "Statistic methods"
.IP "\fIsysinfo()\fR" 4
.IX Item "sysinfo()"
.PD 0
.IP "\fIcpustats()\fR" 4
.IX Item "cpustats()"
.IP "\fIprocstats()\fR" 4
.IX Item "procstats()"
.IP "\fImemstats()\fR" 4
.IX Item "memstats()"
.IP "\fIpgswstats()\fR" 4
.IX Item "pgswstats()"
.IP "\fInetstats()\fR" 4
.IX Item "netstats()"
.IP "\fInetinfo()\fR" 4
.IX Item "netinfo()"
.PD
\&\f(CW\*(C`netinfo()\*(C'\fR provides raw data \- no deltas.
.IP "\fIsockstats()\fR" 4
.IX Item "sockstats()"
.PD 0
.IP "\fIdiskstats()\fR" 4
.IX Item "diskstats()"
.IP "\fIdiskusage()\fR" 4
.IX Item "diskusage()"
.IP "\fIloadavg()\fR" 4
.IX Item "loadavg()"
.IP "\fIfilestats()\fR" 4
.IX Item "filestats()"
.IP "\fIprocesses()\fR" 4
.IX Item "processes()"
.PD
.PP
All methods returns the statistics as a hash reference in scalar context. In list all methods
returns the first level keys of the statistics. Example:
.PP
.Vb 6
\&    my $net  = $stat\->netstats;                 # netstats as a hash reference
\&    my @dev  = $stat\->netstats;                 # the devices eth0, eth1, ...
\&    my $eth0 = $stat\->netstats(\*(Aqeth0\*(Aq);         # eth0 statistics as a hash reference
\&    my @keys = $stat\->netstats(\*(Aqeth0\*(Aq);         # the statistic keys
\&    my @vals = $stat\->netstats(\*(Aqeth0\*(Aq, @keys);  # the values for the passed device and @keys
\&    my $val  = $stat\->netstats(\*(Aqeth0\*(Aq, $key);   # the value for the passed device and key
.Ve
.PP
Sorted ...
.PP
.Vb 2
\&    my @dev  = sort $stat\->netstats;
\&    my @keys = sort $stat\->netstats(\*(Aqeth0\*(Aq);
.Ve
.SS "\fIpstop()\fP"
.IX Subsection "pstop()"
This method is looking for top processes and returns a sorted list of PIDs as an array or
array reference depending on the context. It expected two values: a key name and the number
of top processes to return.
.PP
As example you want to get the top 5 processes with the highest cpu usage:
.PP
.Vb 3
\&    my @top5 = $stat\->pstop( ttime => 5 );
\&    # or as a reference
\&    my $top5 = $stat\->pstop( ttime => 5 );
.Ve
.PP
If you want to get all processes:
.PP
.Vb 3
\&    my @top_all = $stat\->pstop( ttime => $FALSE );
\&    # or just
\&    my @top_all = $stat\->pstop( \*(Aqttime\*(Aq );
.Ve
.SS "\fIsearch()\fP, \fIpsfind()\fP"
.IX Subsection "search(), psfind()"
Both methods provides a simple scan engine to find special statistics. Both methods except a filter
as a hash reference. It's possible to pass the statistics as second argument if the data is not stored
in the object.
.PP
The method \f(CW\*(C`search()\*(C'\fR scans for statistics and rebuilds the hash tree until that keys that matched
your filter and returns the hits as a hash reference.
.PP
.Vb 10
\&    my $hits = $stat\->search({
\&        processes => {
\&            cmd   => qr/\e[su\e]/,
\&            owner => qr/root/
\&        },
\&        cpustats => {
\&            idle   => \*(Aqlt:10\*(Aq,
\&            iowait => \*(Aqgt:10\*(Aq
\&        },
\&        diskusage => {
\&            \*(Aq/dev/sda1\*(Aq => {
\&                usageper => \*(Aqgt:80\*(Aq
\&            }
\&        }
\&    });
.Ve
.PP
This would return the following matches:
.PP
.Vb 5
\&    * processes with the command "[su]"
\&    * processes with the owner "root"
\&    * all cpu where "idle" is less than 50
\&    * all cpu where "iowait" is grather than 10
\&    * only disk \*(Aq/dev/sda1\*(Aq if "usageper" is grather than 80
.Ve
.PP
The method \f(CW\*(C`psfind()\*(C'\fR scans for processes only and returns a array reference with all process
IDs that matched the filter. Example:
.PP
.Vb 1
\&    my $pids = $stat\->psfind({ cmd => qr/init/, owner => \*(Aqeq:apache\*(Aq });
.Ve
.PP
This would return the following process ids:
.PP
.Vb 2
\&    * processes that matched the command "init"
\&    * processes with the owner "apache"
.Ve
.PP
There are different match operators available:
.PP
.Vb 4
\&    gt  \-  grather than
\&    lt  \-  less than
\&    eq  \-  is equal
\&    ne  \-  is not equal
.Ve
.PP
Notation examples:
.PP
.Vb 4
\&    gt:50
\&    lt:50
\&    eq:50
\&    ne:50
.Ve
.PP
Both argumnents have to be set as a hash reference.
.PP
Note: the operators < > = ! are not available any more. It's possible that in further releases
could be different changes for \f(CW\*(C`search()\*(C'\fR and \f(CW\*(C`psfind()\*(C'\fR. So please take a look to the 
documentation if you use it.
.SH "EXPORTS"
.IX Header "EXPORTS"
No exports.
.SH "TODOS"
.IX Header "TODOS"
.Vb 1
\&   * Are there any wishs from your side? Send me a mail!
.Ve
.SH "REPORTING BUGS"
.IX Header "REPORTING BUGS"
Please report all bugs to <jschulz.cpan(at)bloonix.de>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jonny Schulz <jschulz.cpan(at)bloonix.de>.
.PP
Thanks to Moritz Lenz for his suggestion for the name of this module.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
