.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Sys::Statistics::Linux 3"
.TH Sys::Statistics::Linux 3 "2016-02-09" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Sys::Statistics::Linux \- Front\-end module to collect system statistics
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Sys::Statistics::Linux;
\&
\&    my $lxs = Sys::Statistics::Linux\->new(
\&        sysinfo   => 1,
\&        cpustats  => 1,
\&        procstats => 1,
\&        memstats  => 1,
\&        pgswstats => 1,
\&        netstats  => 1,
\&        sockstats => 1,
\&        diskstats => 1,
\&        diskusage => 1,
\&        loadavg   => 1,
\&        filestats => 1,
\&        processes => 1,
\&    );
\&
\&    sleep 1;
\&    my $stat = $lxs\->get;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Sys::Statistics::Linux is a front-end module and gather different linux system information
like processor workload, memory usage, network and disk statistics and a lot more. Refer the
documentation of the distribution modules to get more information about all possible statistics.
.SH "MOTIVATION"
.IX Header "MOTIVATION"
My motivation is very simple... every linux administrator knows the well-known tool sar of sysstat.
It helps me a lot of time to search for system bottlenecks and to solve problems, but it's hard to
parse the output if you want to store the statistics into a database. So I thought to develope
Sys::Statistics::Linux. It's not a replacement but it should make it simpler to you to write your
own system monitor.
.PP
If Sys::Statistics::Linux doesn't provide statistics that are strongly needed then let me know it.
.SH "TECHNICAL NOTE"
.IX Header "TECHNICAL NOTE"
This distribution collects statistics by the virtual \fI/proc\fR filesystem (procfs) and is
developed on the default vanilla kernel. It is tested on x86 hardware with the distributions
\&\s-1RHEL,\s0 Fedora, Debian, Ubuntu, Asianux, Slackware, Mandriva and openSuSE (\s-1SLES\s0 on zSeries as
well but a long time ago) on kernel versions 2.4 and/or 2.6. It's possible that it doesn't
run on all linux distributions if some procfs features are deactivated or too much modified.
As example the linux kernel 2.4 can compiled with the option \f(CW\*(C`CONFIG_BLK_STATS\*(C'\fR what turn
on or off block statistics for devices.
.PP
Don't give up if some of the modules doesn't run on your hardware! Tell me what's wrong
and I will try to solve it! You just have to make the first move and to send me a mail. :\-)
.SH "VIRTUAL MACHINES"
.IX Header "VIRTUAL MACHINES"
Note that if you try to install or run \f(CW\*(C`Sys::Statistics::Linux\*(C'\fR under virtual machines
on guest systems that some statistics are not available, such as \f(CW\*(C`SockStats\*(C'\fR, \f(CW\*(C`PgSwStats\*(C'\fR
and \f(CW\*(C`DiskStats\*(C'\fR. The reason is that not all /proc data are passed to the guests.
.PP
If the installation fails then try to force the installation with
.PP
.Vb 1
\&    cpan> force install Sys::Statistics::Linux
.Ve
.PP
and notice which tests fails, because this statistics maybe not available on the virtual machine \- sorry.
.SH "DELTAS"
.IX Header "DELTAS"
The statistics for \f(CW\*(C`CpuStats\*(C'\fR, \f(CW\*(C`ProcStats\*(C'\fR, \f(CW\*(C`PgSwStats\*(C'\fR, \f(CW\*(C`NetStats\*(C'\fR, \f(CW\*(C`DiskStats\*(C'\fR and \f(CW\*(C`Processes\*(C'\fR
are deltas, for this reason it's necessary to initialize the statistics before the data can be
prepared by \f(CW\*(C`get()\*(C'\fR. These statistics can be initialized with the methods \f(CW\*(C`new()\*(C'\fR, \f(CW\*(C`set()\*(C'\fR and
\&\f(CW\*(C`init()\*(C'\fR. For any option that is set to 1, the statistics will be initialized by the call of
\&\f(CW\*(C`new()\*(C'\fR or \f(CW\*(C`set()\*(C'\fR. The call of \fIinit()\fR re-initialize all statistics that are set to 1 or 2.
By the call of \f(CW\*(C`get()\*(C'\fR the initial statistics will be updated automatically. Please refer the
section \*(L"\s-1METHODS\*(R"\s0 to get more information about the usage of \f(CW\*(C`new()\*(C'\fR, \f(CW\*(C`set()\*(C'\fR, \f(CW\*(C`init()\*(C'\fR
and \f(CW\*(C`get()\*(C'\fR.
.PP
Another exigence is to sleep for a while \- at least for one second \- before the call of \f(CW\*(C`get()\*(C'\fR
if you want to get useful statistics. The statistics for \f(CW\*(C`SysInfo\*(C'\fR, \f(CW\*(C`MemStats\*(C'\fR, \f(CW\*(C`SockStats\*(C'\fR,
\&\f(CW\*(C`DiskUsage\*(C'\fR, \f(CW\*(C`LoadAVG\*(C'\fR and \f(CW\*(C`FileStats\*(C'\fR are no deltas. If you need only one of these information
you don't need to sleep before the call of \f(CW\*(C`get()\*(C'\fR.
.PP
The method \f(CW\*(C`get()\*(C'\fR prepares all requested statistics and returns the statistics as a
Sys::Statistics::Linux::Compilation object. The inital statistics will be updated.
.SH "MANUAL \fIPROC\fP\|(5)"
.IX Header "MANUAL PROC"
The Linux Programmer's Manual
.PP
.Vb 1
\&    http://www.kernel.org/doc/man\-pages/online/pages/man5/proc.5.html
.Ve
.PP
If you have questions or don't understand the sense of some statistics then take a look
into this awesome documentation.
.SH "OPTIONS"
.IX Header "OPTIONS"
All options are identical with the package names of the distribution in lowercase. To activate
the gathering of statistics you have to set the options by the call of \f(CW\*(C`new()\*(C'\fR or \f(CW\*(C`set()\*(C'\fR.
In addition you can deactivate statistics with \f(CW\*(C`set()\*(C'\fR.
.PP
The options must be set with one of the following values:
.PP
.Vb 3
\&    0 \- deactivate statistics
\&    1 \- activate and init statistics
\&    2 \- activate statistics but don\*(Aqt init
.Ve
.PP
In addition it's possible to pass a hash reference with options.
.PP
.Vb 10
\&    my $lxs = Sys::Statistics::Linux\->new(
\&        processes => {
\&            init => 1,
\&            pids => [ 1, 2, 3 ]
\&        },
\&        netstats => {
\&            init => 1,
\&            initfile => $file,
\&        },
\&    );
.Ve
.PP
Option \f(CW\*(C`initfile\*(C'\fR is useful if you want to store initial statistics on the filesystem.
.PP
.Vb 10
\&    my $lxs = Sys::Statistics::Linux\->new(
\&        cpustats => {
\&            init     => 1,
\&            initfile => \*(Aq/tmp/cpustats.yml\*(Aq,
\&        },
\&        diskstats => {
\&            init     => 1,
\&            initfile => \*(Aq/tmp/diskstats.yml\*(Aq,
\&        },
\&        netstats => {
\&            init     => 1,
\&            initfile => \*(Aq/tmp/netstats.yml\*(Aq,
\&        },
\&        pgswstats => {
\&            init     => 1,
\&            initfile => \*(Aq/tmp/pgswstats.yml\*(Aq,
\&        },
\&        procstats => {
\&            init     => 1,
\&            initfile => \*(Aq/tmp/procstats.yml\*(Aq,
\&        },
\&    );
.Ve
.PP
Example:
.PP
.Vb 4
\&    #!/usr/bin/perl
\&    use strict;
\&    use warnings;
\&    use Sys::Statistics::Linux;
\&
\&    my $lxs = Sys::Statistics::Linux\->new(
\&        pgswstats => {
\&            init => 1,
\&            initfile => \*(Aq/tmp/pgswstats.yml\*(Aq
\&        }
\&    );
\&
\&    $lxs\->get(); # without to sleep
.Ve
.PP
The initial statistics are stored to the temporary file:
.PP
.Vb 9
\&    #> cat /tmp/pgswstats.yml
\&    \-\-\- 
\&    pgfault: 397040955
\&    pgmajfault: 4611
\&    pgpgin: 21531693
\&    pgpgout: 49511043
\&    pswpin: 8
\&    pswpout: 272
\&    time: 1236783534.9328
.Ve
.PP
Every time you call the script the initial statistics are loaded/stored from/to the file.
This could be helpful if you doesn't run it as daemon and if you want to calculate the
average load of your system since the last call. Do you understand? I hope so :)
.PP
To get more information about the statistics refer the different modules of the distribution.
.PP
.Vb 12
\&    sysinfo     \-  Collect system information              with Sys::Statistics::Linux::SysInfo.
\&    cpustats    \-  Collect cpu statistics                  with Sys::Statistics::Linux::CpuStats.
\&    procstats   \-  Collect process statistics              with Sys::Statistics::Linux::ProcStats.
\&    memstats    \-  Collect memory statistics               with Sys::Statistics::Linux::MemStats.
\&    pgswstats   \-  Collect paging and swapping statistics  with Sys::Statistics::Linux::PgSwStats.
\&    netstats    \-  Collect net statistics                  with Sys::Statistics::Linux::NetStats.
\&    sockstats   \-  Collect socket statistics               with Sys::Statistics::Linux::SockStats.
\&    diskstats   \-  Collect disk statistics                 with Sys::Statistics::Linux::DiskStats.
\&    diskusage   \-  Collect the disk usage                  with Sys::Statistics::Linux::DiskUsage.
\&    loadavg     \-  Collect the load average                with Sys::Statistics::Linux::LoadAVG.
\&    filestats   \-  Collect inode statistics                with Sys::Statistics::Linux::FileStats.
\&    processes   \-  Collect process statistics              with Sys::Statistics::Linux::Processes.
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "\fInew()\fP"
.IX Subsection "new()"
Call \f(CW\*(C`new()\*(C'\fR to create a new Sys::Statistics::Linux object. You can call \f(CW\*(C`new()\*(C'\fR with options.
This options would be passed to the method \f(CW\*(C`set()\*(C'\fR.
.PP
Without options
.PP
.Vb 1
\&    my $lxs = Sys::Statistics::Linux\->new();
.Ve
.PP
Or with options
.PP
.Vb 1
\&    my $lxs = Sys::Statistics::Linux\->new( cpustats => 1 );
.Ve
.PP
Would do nothing
.PP
.Vb 1
\&    my $lxs = Sys::Statistics::Linux\->new( cpustats => 0 );
.Ve
.PP
It's possible to call \f(CW\*(C`new()\*(C'\fR with a hash reference of options.
.PP
.Vb 4
\&    my %options = (
\&        cpustats => 1,
\&        memstats => 1
\&    );
\&
\&    my $lxs = Sys::Statistics::Linux\->new(\e%options);
.Ve
.SS "\fIset()\fP"
.IX Subsection "set()"
Call \f(CW\*(C`set()\*(C'\fR to activate or deactivate options.
.PP
The following example would call \f(CW\*(C`new()\*(C'\fR and initialize \f(CW\*(C`Sys::Statistics::Linux::CpuStats\*(C'\fR
and delete the object of \f(CW\*(C`Sys::Statistics::Linux::SysInfo\*(C'\fR.
.PP
.Vb 5
\&    $lxs\->set(
\&        processes =>  0, # deactivate this statistic
\&        pgswstats =>  1, # activate the statistic and calls new() and init() if necessary
\&        netstats  =>  2, # activate the statistic and call new() if necessary but not init()
\&    );
.Ve
.PP
It's possible to call \f(CW\*(C`set()\*(C'\fR with a hash reference of options.
.PP
.Vb 4
\&    my %options = (
\&        cpustats => 2,
\&        memstats => 2
\&    );
\&
\&    $lxs\->set(\e%options);
.Ve
.SS "\fIget()\fP"
.IX Subsection "get()"
Call \f(CW\*(C`get()\*(C'\fR to get the collected statistics. \f(CW\*(C`get()\*(C'\fR returns a Sys::Statistics::Linux::Compilation
object.
.PP
.Vb 3
\&    my $lxs  = Sys::Statistics::Linux\->new(\e%options);
\&    sleep(1);
\&    my $stat = $lxs\->get();
.Ve
.PP
Or you can pass the time to sleep with the call of \f(CW\*(C`get()\*(C'\fR.
.PP
.Vb 1
\&    my $stat = $lxs\->get($time_to_sleep);
.Ve
.PP
Now the statistcs are available with
.PP
.Vb 1
\&    $stat\->cpustats
\&
\&    # or
\&
\&    $stat\->{cpustats}
.Ve
.PP
Take a look to the documentation of Sys::Statistics::Linux::Compilation for more information.
.SS "\fIinit()\fP"
.IX Subsection "init()"
The call of \f(CW\*(C`init()\*(C'\fR initiate all activated statistics that are necessary for deltas. That could
be helpful if your script runs in a endless loop with a high sleep interval. Don't forget that if
you call \f(CW\*(C`get()\*(C'\fR that the statistics are deltas since the last time they were initiated.
.PP
The following example would calculate average statistics for 30 minutes:
.PP
.Vb 2
\&    # initiate cpustats
\&    my $lxs = Sys::Statistics::Linux\->new( cpustats => 1 );
\&
\&    while ( 1 ) {
\&        sleep(1800);
\&        my $stat = $lxs\->get;
\&    }
.Ve
.PP
If you just want a current snapshot of the system each 30 minutes and not the average
then the following example would be better for you:
.PP
.Vb 2
\&    # do not initiate cpustats
\&    my $lxs = Sys::Statistics::Linux\->new( cpustats => 2 );
\&
\&    while ( 1 ) {
\&        $lxs\->init;              # init the statistics
\&        my $stat = $lxs\->get(1); # get the statistics
\&        sleep(1800);             # sleep until the next run
\&    }
.Ve
.PP
If you want to write a simple command line utility that prints the current workload
to the screen then you can use something like this:
.PP
.Vb 2
\&    my @order = qw(user system iowait idle nice irq softirq total);
\&    printf "%\-20s%8s%8s%8s%8s%8s%8s%8s%8s\en", \*(Aqtime\*(Aq, @order;
\&
\&    my $lxs = Sys::Statistics::Linux\->new( cpustats => 1 );
\&
\&    while ( 1 ){
\&        my $cpu  = $lxs\->get(1)\->cpustats;
\&        my $time = $lxs\->gettime;
\&        printf "%\-20s%8s%8s%8s%8s%8s%8s%8s%8s\en",
\&            $time, @{$cpu\->{cpu}}{@order};
\&    }
.Ve
.SS "\fIsettime()\fP"
.IX Subsection "settime()"
Call \f(CW\*(C`settime()\*(C'\fR to define a \s-1POSIX\s0 formatted time stamp, generated with \fIlocaltime()\fR.
.PP
.Vb 1
\&    $lxs\->settime(\*(Aq%Y/%m/%d %H:%M:%S\*(Aq);
.Ve
.PP
To get more information about the formats take a look at \f(CW\*(C`strftime()\*(C'\fR of \s-1POSIX\s0.pm
or the manpage \f(CWstrftime(3)\fR.
.SS "\fIgettime()\fP"
.IX Subsection "gettime()"
\&\f(CW\*(C`gettime()\*(C'\fR returns a \s-1POSIX\s0 formatted time stamp, \f(CW@foo\fR in list and \f(CW$bar\fR in scalar context.
If the time format isn't set then the default format \*(L"%Y\-%m\-%d \f(CW%H:\fR%M:%S\*(R" will be set
automatically. You can also set a time format with \f(CW\*(C`gettime()\*(C'\fR.
.PP
.Vb 1
\&    my $date_time = $lxs\->gettime;
.Ve
.PP
Or
.PP
.Vb 1
\&    my ($date, $time) = $lxs\->gettime();
.Ve
.PP
Or
.PP
.Vb 1
\&    my ($date, $time) = $lxs\->gettime(\*(Aq%Y/%m/%d %H:%M:%S\*(Aq);
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
A very simple perl script could looks like this:
.PP
.Vb 3
\&    use strict;
\&    use warnings;
\&    use Sys::Statistics::Linux;
\&
\&    my $lxs = Sys::Statistics::Linux\->new( cpustats => 1 );
\&    sleep(1);
\&    my $stat = $lxs\->get;
\&    my $cpu  = $stat\->cpustats\->{cpu};
\&
\&    print "Statistics for CpuStats (all)\en";
\&    print "  user      $cpu\->{user}\en";
\&    print "  nice      $cpu\->{nice}\en";
\&    print "  system    $cpu\->{system}\en";
\&    print "  idle      $cpu\->{idle}\en";
\&    print "  ioWait    $cpu\->{iowait}\en";
\&    print "  total     $cpu\->{total}\en";
.Ve
.PP
Set and get a time stamp:
.PP
.Vb 3
\&    use strict;
\&    use warnings;
\&    use Sys::Statistics::Linux;
\&
\&    my $lxs = Sys::Statistics::Linux\->new();
\&    $lxs\->settime(\*(Aq%Y/%m/%d %H:%M:%S\*(Aq);
\&    print $lxs\->gettime, "\en";
.Ve
.PP
If you want to know how the data structure looks like you can use \f(CW\*(C`Data::Dumper\*(C'\fR to check it:
.PP
.Vb 4
\&    use strict;
\&    use warnings;
\&    use Sys::Statistics::Linux;
\&    use Data::Dumper;
\&
\&    my $lxs = Sys::Statistics::Linux\->new( cpustats => 1 );
\&    sleep(1);
\&    my $stat = $lxs\->get;
\&
\&    print Dumper($stat);
.Ve
.PP
How to get the top 5 processes with the highest cpu workload:
.PP
.Vb 3
\&    use strict;
\&    use warnings;
\&    use Sys::Statistics::Linux;
\&
\&    my $lxs = Sys::Statistics::Linux\->new( processes => 1 );
\&    sleep(1);
\&    my $stat = $lxs\->get;
\&    my @top5 = $stat\->pstop( ttime => 5 );
.Ve
.SH "BACKWARD COMPATIBILITY"
.IX Header "BACKWARD COMPATIBILITY"
The old options and keys \- CpuStats, NetStats, etc \- are still available but deprecated!
It's not possible to access the statistics via Sys::Statistics::Linux::Compilation and it's
not possible to call \f(CW\*(C`search()\*(C'\fR and \f(CW\*(C`psfind()\*(C'\fR if you use the old options.
.PP
You should use the new options and access the statistics over the accessors
.PP
.Vb 1
\&    $stats\->cpustats
.Ve
.PP
or directly with
.PP
.Vb 1
\&    $stats\->{cpustats}
.Ve
.SH "PREREQUISITES"
.IX Header "PREREQUISITES"
.Vb 5
\&    Carp
\&    POSIX
\&    Test::More
\&    Time::HiRes
\&    UNIVERSAL
.Ve
.SH "EXPORTS"
.IX Header "EXPORTS"
No exports.
.SH "TODOS"
.IX Header "TODOS"
.Vb 1
\&   * Are there any wishs from your side? Send me a mail!
.Ve
.SH "REPORTING BUGS"
.IX Header "REPORTING BUGS"
Please report all bugs to <jschulz.cpan(at)bloonix.de>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jonny Schulz <jschulz.cpan(at)bloonix.de>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2006\-2008 by Jonny Schulz. All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
